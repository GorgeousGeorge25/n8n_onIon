/**
 * Schema-to-TypeScript transformation engine
 * Converts n8n node schemas into type-safe TypeScript interfaces
 */

import type { N8nNodeType } from '../schema/types.js';
import { analyzeDisplayOptions, buildDiscriminatedUnions, deduplicateProperties } from './conditional.js';

/**
 * Shared TypeScript type definitions
 */
const SHARED_TYPES = `/**
 * Expression type for n8n expression fields
 * Allows dynamic values using n8n expression syntax
 */
export interface Expression<T> {
  __expression: string;
  __type?: T;
}

/**
 * ResourceLocator type for n8n resource selection
 * Supports both object form and string shorthand
 */
export interface ResourceLocator {
  __rl: true;
  mode: 'list' | 'id' | 'name' | 'url';
  value: string;
  cachedResultName?: string;
  cachedResultUrl?: string;
}
`;

/**
 * Generates TypeScript type definitions for a single node
 */
export function generateNodeType(schema: N8nNodeType): string {
  const nodeName = extractNodeName(schema.name);
  const tree = analyzeDisplayOptions(schema.properties);

  // If has resource/operation pattern, use discriminated unions
  if (tree.branches.size > 0) {
    return buildDiscriminatedUnions(nodeName, tree);
  }

  // Otherwise, generate a simple interface with deduplicated properties
  const dedupedProps = deduplicateProperties(tree.commonProperties);
  const fieldMap = new Map<string, { optional: boolean; types: Set<string>; order: number }>();
  let order = 0;

  for (const prop of dedupedProps) {
    const optional = prop.required ? '' : '?';
    const tsType = mapPropertyType(prop);
    const name = prop.name;

    const existing = fieldMap.get(name);
    if (existing) {
      existing.types.add(tsType);
      if (optional === '?') existing.optional = true;
    } else {
      fieldMap.set(name, { optional: optional === '?', types: new Set([tsType]), order: order++ });
    }
  }

  const fields: string[] = [];
  const sorted = [...fieldMap.entries()].sort((a, b) => a[1].order - b[1].order);
  for (const [name, entry] of sorted) {
    const opt = entry.optional ? '?' : '';
    const mergedType = [...entry.types].join(' | ');
    fields.push(`  ${name}${opt}: ${mergedType};`);
  }

  return `export interface ${nodeName}Node {\n${fields.join('\n')}\n}`;
}

/**
 * Generates TypeScript type definitions for multiple nodes
 */
export function generateNodeTypes(schemas: N8nNodeType[]): string {
  const parts: string[] = [];

  // Add header comment
  parts.push('/**');
  parts.push(' * Auto-generated n8n node type definitions');
  parts.push(' * DO NOT EDIT MANUALLY - Generated by npm run generate');
  parts.push(' */');
  parts.push('');

  // Add shared types
  parts.push(SHARED_TYPES);
  parts.push('');

  // Generate types for each node
  for (const schema of schemas) {
    parts.push(generateNodeType(schema));
    parts.push('');
  }

  return parts.join('\n');
}

/**
 * Extracts clean node name from full n8n node type name
 * e.g., "n8n-nodes-base.slack" -> "Slack"
 */
function extractNodeName(fullName: string): string {
  const parts = fullName.split('.');
  const name = parts[parts.length - 1];
  return name.charAt(0).toUpperCase() + name.slice(1);
}

/**
 * Builds a deduplicated inline object type string from sub-properties.
 */
function buildInlineObjectType(subProps: any[]): string {
  const rawFields = subProps.map((sp: any) => {
    const optional = sp.required ? '' : '?';
    return `${sp.name}${optional}: ${mapPropertyType(sp)}`;
  });
  const dedupedFields = deduplicateSubFields(rawFields);
  return `{ ${dedupedFields.join('; ')} }`;
}

/**
 * Deduplicates inline object field strings by property name.
 */
function deduplicateSubFields(fields: string[]): string[] {
  const seen = new Map<string, { optional: boolean; types: Set<string>; order: number }>();
  let order = 0;

  for (const field of fields) {
    const match = field.match(/^(\w+)(\??):\s*(.+)$/);
    if (!match) {
      seen.set(`__raw_${order}`, { optional: false, types: new Set([field]), order: order++ });
      continue;
    }
    const [, name, optMarker, typeStr] = match;
    const isOptional = optMarker === '?';
    const existing = seen.get(name);
    if (existing) {
      existing.types.add(typeStr);
      if (isOptional) existing.optional = true;
    } else {
      seen.set(name, { optional: isOptional, types: new Set([typeStr]), order: order++ });
    }
  }

  const entries = [...seen.entries()].sort((a, b) => a[1].order - b[1].order);
  const result: string[] = [];
  for (const [key, entry] of entries) {
    if (key.startsWith('__raw_')) {
      result.push([...entry.types][0]);
      continue;
    }
    const opt = entry.optional ? '?' : '';
    const mergedType = [...entry.types].join(' | ');
    result.push(`${key}${opt}: ${mergedType}`);
  }
  return result;
}

/**
 * Maps n8n property type to TypeScript type
 * This is a helper that delegates to the conditional.ts version for consistency
 */
function mapPropertyType(prop: any): string {
  // Import the logic from conditional.ts to avoid duplication
  // For now, inline a simplified version
  let baseType: string;

  switch (prop.type) {
    case 'string':
      baseType = 'string';
      break;
    case 'number':
      baseType = 'number';
      break;
    case 'boolean':
      baseType = 'boolean';
      break;
    case 'json':
      baseType = 'unknown';
      break;
    case 'options':
      if (prop.options && Array.isArray(prop.options)) {
        const values = prop.options
          .map((o: any) => typeof o.value === 'string' ? `'${o.value}'` : o.value)
          .join(' | ');
        baseType = values || 'string';
      } else {
        baseType = 'string';
      }
      break;
    case 'multiOptions':
      if (prop.options && Array.isArray(prop.options)) {
        const values = prop.options
          .map((o: any) => typeof o.value === 'string' ? `'${o.value}'` : o.value)
          .join(' | ');
        baseType = `Array<${values || 'string'}>`;
      } else {
        baseType = 'string[]';
      }
      break;
    case 'resourceLocator':
      baseType = 'ResourceLocator | string';
      break;
    case 'collection':
      if (prop.options && Array.isArray(prop.options)) {
        baseType = buildInlineObjectType(prop.options);
      } else {
        baseType = 'Record<string, unknown>';
      }
      break;
    case 'fixedCollection':
      if (prop.options && Array.isArray(prop.options)) {
        const groups = prop.options;
        const dedupedGroupFields = deduplicateSubFields(groups.map((group: any) => {
          const optional = group.required ? '' : '?';
          let groupType = 'unknown';

          if (group.values && Array.isArray(group.values)) {
            groupType = buildInlineObjectType(group.values);
          }

          return `${group.name}${optional}: ${groupType}`;
        }));
        baseType = `{ ${dedupedGroupFields.join('; ')} }`;
      } else {
        baseType = 'Record<string, unknown>';
      }
      break;
    default:
      baseType = 'unknown';
  }

  // Wrap with Expression<T> if field supports expressions
  if (!prop.noDataExpression && (prop.type === 'string' || prop.type === 'number' || prop.type === 'boolean')) {
    return `${baseType} | Expression<${baseType}>`;
  }

  return baseType;
}
