---
phase: 05.3-automated-workflow-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/executor/types.ts
  - src/executor/execute.ts
autonomous: true

must_haves:
  truths:
    - "SDK can trigger a Manual Trigger workflow execution via n8n API"
    - "SDK can poll execution status and retrieve output data"
    - "SDK can delete workflows for cleanup"
  artifacts:
    - path: "src/executor/types.ts"
      provides: "ExecutionResult, ExecutionOptions, TestScenario types"
      exports: ["ExecutionResult", "ExecutionOptions", "ExecutionStatus"]
    - path: "src/executor/execute.ts"
      provides: "executeWorkflow, getExecution, deleteWorkflow functions"
      exports: ["executeWorkflow", "getExecution", "deleteWorkflow"]
  key_links:
    - from: "src/executor/execute.ts"
      to: "n8n API"
      via: "fetch calls to /api/v1/workflows/{id}/execute, /api/v1/executions/{id}, DELETE /api/v1/workflows/{id}"
      pattern: "fetch.*api/v1"
---

<objective>
Research n8n execution API endpoints on live instance, then build the executor module with types and core functions.

Purpose: The n8n execution API is UNVERIFIED. Before building anything, we must confirm which endpoints exist, what they accept, and what they return. Then build the low-level executor (trigger execution, poll results, delete workflow) that the test harness will use.

Output: `src/executor/types.ts` and `src/executor/execute.ts` — the execution primitives.
</objective>

<execution_context>
@/Users/jurissleiners/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jurissleiners/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/deployer/deploy.ts
@src/deployer/types.ts
@src/compiler/tests/integration.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Research n8n execution API on live instance</name>
  <files>No files created — research only</files>
  <action>
Call the live n8n instance at http://localhost:5678 to discover the execution API. Use the same auth pattern as existing code (X-N8N-API-KEY header from .env).

Research these endpoints in order:

1. **Manual trigger execution**: Try `POST /api/v1/workflows/{id}/execute` — first deploy a simple Manual Trigger -> Set workflow using the existing deployWorkflow pattern, then try to execute it. If that endpoint doesn't exist, try `POST /api/v1/executions` with `{ workflowId }`. Document the request shape and response shape.

2. **Get execution result**: Try `GET /api/v1/executions/{id}` — use the execution ID from step 1. Document the response shape: status field (running/success/error/waiting), output data location (which field contains node outputs), error message location.

3. **Webhook trigger**: Deploy a Webhook trigger workflow (activated), then try `POST /webhook-test/{path}` with a JSON body. Document whether this returns execution data inline or requires polling.

4. **Delete workflow**: Try `DELETE /api/v1/workflows/{id}` — use the test workflow from step 1. Document response shape.

For each endpoint, capture: HTTP method, URL, request body (if any), response status, response body structure. Use curl or fetch via a quick script. Log actual responses — do NOT guess.

If an endpoint doesn't exist (404), document it and note the alternative. Adjust the subsequent task accordingly.

IMPORTANT: Clean up any workflows created during research (delete them).
  </action>
  <verify>
Research produces documented API shapes for: execute workflow, get execution, webhook trigger, and delete workflow. Each has actual response data from the live n8n instance.
  </verify>
  <done>All 4 execution API endpoints verified with actual request/response shapes from live n8n. Any missing endpoints documented with alternatives.</done>
</task>

<task type="auto">
  <name>Task 2: Build executor module — types and core functions</name>
  <files>src/executor/types.ts, src/executor/execute.ts</files>
  <action>
Based on the API research from Task 1, create the executor module.

**src/executor/types.ts** — Define these types:

```typescript
export type ExecutionStatus = 'new' | 'running' | 'success' | 'error' | 'waiting' | 'canceled';

export interface ExecutionResult {
  id: string;                    // Execution ID
  status: ExecutionStatus;       // Final status
  finished: boolean;             // Whether execution completed
  data: NodeExecutionData[];     // Per-node output data
  error?: ExecutionError;        // Error details if failed
  startedAt: string;             // ISO timestamp
  stoppedAt?: string;            // ISO timestamp (null if still running)
}

export interface NodeExecutionData {
  nodeName: string;              // Node that produced this data
  data: Record<string, unknown>[];  // Output items from this node
}

export interface ExecutionError {
  message: string;
  node?: string;                 // Which node failed
  stack?: string;
}

export interface ExecutionOptions {
  apiUrl?: string;               // Defaults to N8N_API_URL or http://localhost:5678
  apiKey?: string;               // Defaults to N8N_API_KEY
  pollIntervalMs?: number;       // Polling interval (default 500ms)
  timeoutMs?: number;            // Max wait time (default 30000ms)
}
```

Adjust these types based on what the API research in Task 1 actually revealed. Do NOT assume — use the real response shapes.

**src/executor/execute.ts** — Implement these functions:

1. `executeWorkflow(workflowId: string, options?: ExecutionOptions): Promise<ExecutionResult>` — Triggers execution of a workflow by ID via the API endpoint discovered in Task 1. Polls until execution completes or timeout. Returns parsed execution result with per-node data.

2. `getExecution(executionId: string, options?: ExecutionOptions): Promise<ExecutionResult>` — Fetches a single execution by ID. Parses the n8n response into ExecutionResult format. This is the building block that executeWorkflow uses for polling.

3. `deleteWorkflow(workflowId: string, options?: ExecutionOptions): Promise<void>` — Deletes a workflow by ID. Used for cleanup after testing.

4. `triggerWebhook(path: string, payload: Record<string, unknown>, options?: ExecutionOptions): Promise<unknown>` — POSTs to the webhook-test endpoint. Returns the response body.

All functions should:
- Use the same env var fallback pattern as deploy.ts (options > env vars > defaults)
- Throw descriptive errors on failure
- Parse n8n's nested execution data format into the flat NodeExecutionData[] format

For polling in executeWorkflow:
- Poll getExecution every pollIntervalMs
- Stop when status is 'success', 'error', or 'canceled'
- Throw timeout error if timeoutMs exceeded
- Include execution ID in timeout error message for debugging
  </action>
  <verify>
`npx tsc --noEmit` passes with no type errors in the new files. Manual review confirms the API calls match the shapes discovered in Task 1.
  </verify>
  <done>src/executor/types.ts exports ExecutionResult, ExecutionOptions, ExecutionStatus and related types. src/executor/execute.ts exports executeWorkflow, getExecution, deleteWorkflow, triggerWebhook — all using real API shapes from Task 1 research.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no type errors
2. Types in src/executor/types.ts match actual n8n API response shapes
3. Functions in src/executor/execute.ts use correct endpoints and auth headers
4. Existing 80 tests still pass: `npx vitest run`
</verification>

<success_criteria>
- Executor types defined based on real API shapes (not guesses)
- executeWorkflow, getExecution, deleteWorkflow, triggerWebhook implemented
- All functions use env var fallback pattern consistent with deploy.ts
- TypeScript compiles without errors
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/05.3-automated-workflow-testing/05.3-01-SUMMARY.md`
</output>
