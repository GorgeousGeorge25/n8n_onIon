---
phase: 03-compilation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/compiler/types.ts
  - src/compiler/layout.ts
  - src/compiler/validation.ts
  - src/compiler/compiler.ts
  - src/compiler/tests/compiler.test.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "compileWorkflow() transforms WorkflowBuilder into valid n8n JSON with nodes, connections, active, settings"
    - "Every compiled node has a unique UUID id"
    - "Every compiled node has a non-overlapping [x, y] position"
    - "Connections transform to n8n nested format: { [fromNode]: { main: [[{ node, type, index }]] } }"
    - "Validation rejects connections referencing non-existent nodes"
  artifacts:
    - path: "src/compiler/types.ts"
      provides: "N8nNode, N8nWorkflow, N8nConnection interfaces"
      contains: "N8nWorkflow"
    - path: "src/compiler/layout.ts"
      provides: "Grid position calculator"
      exports: ["calculateGridPosition"]
    - path: "src/compiler/validation.ts"
      provides: "Connection validation"
      exports: ["validateWorkflow"]
    - path: "src/compiler/compiler.ts"
      provides: "Main compile function"
      exports: ["compileWorkflow"]
    - path: "src/compiler/tests/compiler.test.ts"
      provides: "Tests for compiler, layout, validation"
      min_lines: 50
  key_links:
    - from: "src/compiler/compiler.ts"
      to: "src/builder/types.ts"
      via: "imports WorkflowBuilder, WorkflowNode, WorkflowConnection"
      pattern: "import.*from.*builder/types"
    - from: "src/compiler/compiler.ts"
      to: "src/compiler/layout.ts"
      via: "imports calculateGridPosition"
      pattern: "import.*calculateGridPosition"
    - from: "src/compiler/compiler.ts"
      to: "src/compiler/validation.ts"
      via: "imports validateWorkflow"
      pattern: "import.*validateWorkflow"
---

<objective>
Build the compiler core that transforms WorkflowBuilder data into structurally valid n8n workflow JSON, with UUID generation, grid layout, and connection validation.

Purpose: This is the central transformation that makes the SDK useful -- converting type-safe TypeScript workflow definitions into importable n8n JSON.
Output: src/compiler/ module with types, layout, validation, and compiler, fully tested via TDD.
</objective>

<execution_context>
@/Users/jurissleiners/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jurissleiners/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-compilation/03-RESEARCH.md
@src/builder/types.ts
@src/builder/workflow.ts
@src/expressions/reference.ts
@src/expressions/template.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create compiler types and write failing tests</name>
  <files>src/compiler/types.ts, src/compiler/tests/compiler.test.ts</files>
  <action>
Create `src/compiler/types.ts` with n8n JSON output interfaces:
- `N8nNode`: { id: string, name: string, type: string, typeVersion: number, position: [number, number], parameters: Record<string, unknown> }
- `N8nConnection`: { node: string, type: string, index: number }
- `N8nWorkflow`: { name: string, nodes: N8nNode[], connections: Record<string, { main: Array<Array<N8nConnection>> }>, active: boolean, settings: Record<string, unknown> }

Create `src/compiler/tests/compiler.test.ts` with tests covering:

1. **compileWorkflow basic structure**: Create a workflow with 2 nodes (trigger + action) connected. Assert output has: name matches, nodes array length 2, each node has id (UUID format regex `/^[0-9a-f]{8}-/`), name, type, typeVersion: 1, position as [number, number], parameters. connections object has correct nested format.

2. **UUID uniqueness**: Compile workflow with 3+ nodes. Assert all node IDs are unique.

3. **Grid layout no overlap**: Compile workflow with 5 nodes. Assert all positions are unique (no two nodes at same [x,y]).

4. **Connection format**: Create workflow: A->B, A->C (output index 1). Assert connections[A].main[0] contains B entry, connections[A].main[1] contains C entry. Each entry has { node: string, type: 'main', index: 0 }.

5. **Validation rejects bad connections**: This test verifies the validateWorkflow function throws on unknown node references. Use the builder to create a workflow, then call validateWorkflow directly with nodes and a fabricated bad connection.

6. **Empty workflow compiles**: Workflow with no nodes produces valid structure with empty nodes array and empty connections.

7. **Expression values pass through**: Node parameters containing expression strings (e.g. `={{ $node['X'].json.field }}`) pass through unchanged in compiled output.

Import from `../compiler.js`, `../layout.js`, `../validation.js`, `../types.js`. Use `import { workflow } from '../../builder/workflow.js'` to create test workflows. Run tests -- they MUST fail (RED phase).
  </action>
  <verify>Run `cd /Users/jurissleiners/MyPrograms/n8n_onIon && npx vitest run src/compiler/tests/compiler.test.ts` -- tests should FAIL (modules not found or functions missing).</verify>
  <done>Test file exists with 7+ test cases covering all compiler requirements. All tests fail because implementation doesn't exist yet.</done>
</task>

<task type="auto">
  <name>Task 2: Implement compiler modules to pass all tests</name>
  <files>src/compiler/layout.ts, src/compiler/validation.ts, src/compiler/compiler.ts, src/index.ts</files>
  <action>
Implement `src/compiler/layout.ts`:
- Export `calculateGridPosition(index: number): [number, number]`
- Constants: SPACING_X = 300, SPACING_Y = 200, START_X = 100, START_Y = 100
- Layout: column = Math.floor(index / 3), row = index % 3
- Return [START_X + column * SPACING_X, START_Y + row * SPACING_Y]

Implement `src/compiler/validation.ts`:
- Export `validateWorkflow(nodes: WorkflowNode[], connections: WorkflowConnection[]): void`
- Import WorkflowNode, WorkflowConnection from `../builder/types.js`
- Build Set of node names, iterate connections, throw Error if from or to not in set
- Error messages: `Connection references unknown source: "${conn.from}"` and `Connection references unknown target: "${conn.to}"`

Implement `src/compiler/compiler.ts`:
- Export `compileWorkflow(builder: WorkflowBuilder): N8nWorkflow`
- Import types from `../builder/types.js`, `./types.js`, `./layout.js`, `./validation.js`
- Use `import { randomUUID } from 'crypto'`
- Steps: (1) get nodes/connections from builder, (2) validate, (3) map nodes with randomUUID(), typeVersion: 1, calculateGridPosition(index), (4) build connections object using nested arrays per research pattern, (5) return { name, nodes, connections, active: false, settings: {} }
- Connection building: for each connection, ensure result[from] exists with main array, pad main array to outputIndex length, push { node: to, type: 'main', index: 0 }

Update `src/index.ts`: Add exports for compiler module:
```
export * from './compiler/types.js';
export { compileWorkflow } from './compiler/compiler.js';
export { validateWorkflow } from './compiler/validation.js';
export { calculateGridPosition } from './compiler/layout.js';
```

Run tests -- they MUST pass (GREEN phase).
  </action>
  <verify>Run `cd /Users/jurissleiners/MyPrograms/n8n_onIon && npx vitest run src/compiler/tests/compiler.test.ts` -- all tests pass.</verify>
  <done>All 7+ compiler tests pass. compileWorkflow produces valid n8n JSON with UUIDs, positions, and correct connection format. validateWorkflow rejects invalid connections.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/compiler/tests/compiler.test.ts` -- all tests pass
2. `npx vitest run` -- all project tests pass (no regressions)
3. TypeScript compiles: `npx tsc --noEmit` succeeds
</verification>

<success_criteria>
- compileWorkflow() accepts a WorkflowBuilder and returns N8nWorkflow JSON
- Every node in output has a unique UUID, type, typeVersion, position, and parameters
- Connections use n8n's nested { main: [[{node, type, index}]] } format
- validateWorkflow() throws on invalid node references
- All tests pass, no regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-compilation/03-01-SUMMARY.md`
</output>
