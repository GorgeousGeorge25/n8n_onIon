---
phase: 05-typed-node-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/codegen/generator.ts
  - src/codegen/conditional.ts
  - src/codegen/typed-api.ts
  - src/index.ts
  - generated/nodes.ts
autonomous: true

must_haves:
  truths:
    - "Generated types export individual operation interfaces (SlackMessagePost, SlackChannelCreate, etc.)"
    - "Typed node API provides nodes.slack.message.post(params) style calls returning WorkflowNode"
    - "Codegen module is re-exported from src/index.ts"
    - "Existing untyped builder API continues to work unchanged"
  artifacts:
    - path: "src/codegen/typed-api.ts"
      provides: "Typed node API factory that maps generated types to builder nodes"
      exports: ["createTypedNodes", "TypedNodes"]
    - path: "src/codegen/generator.ts"
      provides: "Updated generator exporting individual interfaces"
    - path: "generated/nodes.ts"
      provides: "Regenerated types with proper exports"
      contains: "export interface SlackMessagePost"
    - path: "src/index.ts"
      provides: "Re-exports codegen module"
      contains: "from './codegen/"
  key_links:
    - from: "src/codegen/generator.ts"
      to: "generated/nodes.ts"
      via: "generateNodeTypes produces exported interfaces"
      pattern: "export interface"
    - from: "src/codegen/typed-api.ts"
      to: "src/builder/types.ts"
      via: "typed API returns WorkflowNode objects"
      pattern: "WorkflowNode"
    - from: "src/index.ts"
      to: "src/codegen/typed-api.ts"
      via: "re-export"
      pattern: "export.*codegen"
---

<objective>
Fix codegen to produce properly exported individual interfaces and create a typed node API that maps `nodes.slack.message.post(params)` calls to WorkflowNode objects with compile-time type checking.

Purpose: Close the tech debt gap where generated types exist but are not consumed by the SDK.
Output: Typed node API module, fixed codegen exports, regenerated nodes.ts, updated index.ts.
</objective>

<execution_context>
@/Users/jurissleiners/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jurissleiners/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/codegen/generator.ts
@src/codegen/conditional.ts
@src/builder/types.ts
@src/builder/workflow.ts
@src/index.ts
@generated/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix codegen to export individual interfaces and re-export from index</name>
  <files>
    src/codegen/generator.ts
    src/codegen/conditional.ts
    src/index.ts
    generated/nodes.ts
  </files>
  <action>
    Fix the type generator to produce properly exported individual interfaces:

    1. In `src/codegen/conditional.ts`, update `buildDiscriminatedUnions()`:
       - Change `interface SlackMessagePost {` to `export interface SlackMessagePost {`
       - The union type line already has `export type`, keep that

    2. In `src/codegen/generator.ts`, update `generateNodeType()`:
       - For simple nodes (no resource/operation pattern), change `interface XNode {` to `export interface XNode {`
       - Remove the self-referential `export type XNode = XNode;` line (replace with nothing — the interface itself is now exported)

    3. In `src/codegen/generator.ts`, update `generateNodeTypes()`:
       - Add `export` to the shared types (Expression, ResourceLocator) so downstream consumers can import them

    4. Regenerate `generated/nodes.ts` by running: `npm run generate`
       - If schemas aren't cached, first run `npm run extract` (needs n8n running)
       - If n8n is not available, manually fix generated/nodes.ts by adding `export` to each `interface` declaration

    5. In `src/index.ts`, add codegen re-exports:
       ```typescript
       // Code generation
       export { generateNodeType, generateNodeTypes } from './codegen/generator.js';
       export { analyzeDisplayOptions, buildDiscriminatedUnions } from './codegen/conditional.js';
       ```
  </action>
  <verify>
    - `grep -c "export interface" generated/nodes.ts` shows all interfaces are exported (no bare `interface` lines)
    - `grep "export type.*=.*;" generated/nodes.ts` shows union types (SlackNode, etc.) but NOT self-referential ones like `export type HttpRequestNode = HttpRequestNode`
    - `npm run build` (tsc) compiles without errors
    - `npm test` still passes all 52 tests
  </verify>
  <done>
    All interfaces in generated/nodes.ts are individually exported. Self-referential type aliases removed. Codegen re-exported from src/index.ts. No regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create typed node API factory</name>
  <files>
    src/codegen/typed-api.ts
  </files>
  <action>
    Create `src/codegen/typed-api.ts` — a typed node API factory that provides `nodes.slack.message.post(params)` style calls:

    1. Define the TypedNodes interface hierarchy using the 5 v1 nodes:
       ```typescript
       import type { WorkflowNode } from '../builder/types.js';

       // Type imports from generated types (these are the parameter shapes)
       // Using inline type definitions that mirror generated interfaces
       // to avoid runtime dependency on generated file

       export interface TypedNodes {
         webhook: (name: string, params: WebhookParams) => WorkflowNode;
         httpRequest: (name: string, params: HttpRequestParams) => WorkflowNode;
         if: (name: string, params: IfParams) => WorkflowNode;
         set: (name: string, params: SetParams) => WorkflowNode;
         slack: {
           message: {
             post: (name: string, params: SlackMessagePostParams) => WorkflowNode;
             update: (name: string, params: SlackMessageUpdateParams) => WorkflowNode;
             delete: (name: string, params: SlackMessageDeleteParams) => WorkflowNode;
             search: (name: string, params: SlackMessageSearchParams) => WorkflowNode;
             getPermalink: (name: string, params: SlackMessageGetPermalinkParams) => WorkflowNode;
           };
           channel: {
             create: (name: string, params: SlackChannelCreateParams) => WorkflowNode;
             archive: (name: string, params: SlackChannelArchiveParams) => WorkflowNode;
             get: (name: string, params: SlackChannelGetParams) => WorkflowNode;
             getAll: (name: string, params: SlackChannelGetAllParams) => WorkflowNode;
             // ... other channel operations
           };
           // ... other resources
         };
       }
       ```

    2. For the param types, re-export from generated/nodes.ts or define minimal types inline that match the generated shapes. Use a pragmatic approach: define param types that reference the generated interfaces.

    3. Create the `createTypedNodes()` factory function:
       ```typescript
       export function createTypedNodes(): TypedNodes {
         function makeNode(type: string, params: Record<string, unknown>, name: string): WorkflowNode {
           return { name, type, parameters: params };
         }

         return {
           webhook: (name, params) => makeNode('n8n-nodes-base.webhook', params as Record<string, unknown>, name),
           httpRequest: (name, params) => makeNode('n8n-nodes-base.httpRequest', params as Record<string, unknown>, name),
           if: (name, params) => makeNode('n8n-nodes-base.if', params as Record<string, unknown>, name),
           set: (name, params) => makeNode('n8n-nodes-base.set', params as Record<string, unknown>, name),
           slack: {
             message: {
               post: (name, params) => makeNode('n8n-nodes-base.slack', { ...params as any, resource: 'message', operation: 'post' }, name),
               // ... other operations inject resource+operation
             },
             // ...
           }
         };
       }
       ```

    4. The key insight: typed params at the call site enforce compile-time checking, but the runtime just spreads them as parameters. The resource/operation discriminants are auto-injected by the factory so the user doesn't need to specify them.

    5. Export from src/index.ts:
       ```typescript
       export { createTypedNodes } from './codegen/typed-api.js';
       export type { TypedNodes } from './codegen/typed-api.js';
       ```

    IMPORTANT: Keep param types practical — cover the most-used operations for the 5 v1 nodes. Don't try to type every single Slack operation. Focus on the ones that have snapshot tests (message.post, channel.create) and the simple nodes (webhook, httpRequest, if, set).
  </action>
  <verify>
    - `npm run build` compiles without errors
    - `npm test` still passes all 52 tests (no regressions)
    - Manual check: `createTypedNodes()` returns an object with the expected shape
  </verify>
  <done>
    Typed node API factory exists at src/codegen/typed-api.ts. Calling `nodes.slack.message.post('name', {...})` returns a WorkflowNode with correct type and auto-injected resource/operation. TypeScript rejects invalid parameters at compile time.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` — TypeScript compilation succeeds
2. `npm test` — All existing 52 tests pass (no regressions)
3. `grep -c "export interface" generated/nodes.ts` — All interfaces exported
4. `grep "createTypedNodes" src/index.ts` — Factory is re-exported
5. Manual: In a .ts file, `createTypedNodes().slack.message.post('x', { text: 'hi' })` compiles, `createTypedNodes().slack.message.post('x', { invalid: true })` produces a type error
</verification>

<success_criteria>
- All generated interfaces individually exported from generated/nodes.ts
- createTypedNodes() factory provides typed access to all 5 v1 nodes
- Slack node uses nested resource.operation.method pattern
- resource/operation values auto-injected (user doesn't specify them)
- Invalid parameters caught at TypeScript compile time
- Existing untyped builder API unchanged
- All 52 existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-typed-node-api/05-01-SUMMARY.md`
</output>
