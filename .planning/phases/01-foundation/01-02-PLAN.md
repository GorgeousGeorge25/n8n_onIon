---
phase: 01-foundation
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/codegen/generator.ts
  - src/codegen/conditional.ts
  - src/codegen/tests/generator.test.ts
  - generated/nodes.ts
  - cli/generate.ts
autonomous: true

must_haves:
  truths:
    - "Generated TypeScript interfaces have discriminated unions keyed on resource+operation (e.g., SlackMessagePost vs SlackChannelCreate are distinct types)"
    - "Options fields generate string literal union types (e.g., 'text' | 'block' not string)"
    - "ResourceLocator parameters accept both {mode, value} objects and plain string shorthand"
    - "Collection and FixedCollection parameters generate typed nested objects (not Record<string, unknown>)"
    - "Running `npm run generate` reads cached schemas and outputs TypeScript files"
  artifacts:
    - path: "src/codegen/generator.ts"
      provides: "Schema-to-TypeScript transformation engine"
      exports: ["generateNodeTypes", "generateNodeType"]
    - path: "src/codegen/conditional.ts"
      provides: "displayOptions conditional analysis and discriminated union generation"
      exports: ["analyzeDisplayOptions", "buildDiscriminatedUnions"]
    - path: "src/codegen/tests/generator.test.ts"
      provides: "TDD tests for type generation"
      contains: "describe.*generator"
    - path: "cli/generate.ts"
      provides: "CLI entry point for type generation"
    - path: "generated/nodes.ts"
      provides: "Auto-generated node type definitions"
  key_links:
    - from: "src/codegen/generator.ts"
      to: "src/schema/cache.ts"
      via: "reads cached schemas"
      pattern: "readAllSchemas|readSchema"
    - from: "src/codegen/generator.ts"
      to: "src/codegen/conditional.ts"
      via: "delegates displayOptions analysis"
      pattern: "analyzeDisplayOptions|buildDiscriminatedUnions"
    - from: "cli/generate.ts"
      to: "src/codegen/generator.ts"
      via: "calls generateNodeTypes and writes output"
      pattern: "generateNodeTypes"
---

<objective>
Implement the type generator that transforms cached n8n schemas into TypeScript interfaces with discriminated unions, string literal types, ResourceLocator support, and collection typing.

Purpose: This is the core intellectual challenge of Phase 1 — turning n8n's runtime displayOptions conditional system into compile-time TypeScript type safety.
Output: Working `npm run generate` that produces typed interfaces from cached schemas.
</objective>

<execution_context>
@/Users/jurissleiners/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jurissleiners/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<feature>
  <name>Schema-to-TypeScript Type Generator</name>
  <files>src/codegen/generator.ts, src/codegen/conditional.ts, src/codegen/tests/generator.test.ts, cli/generate.ts, generated/nodes.ts</files>
  <behavior>
Given a cached n8n node schema (N8nNodeType), the generator produces TypeScript source code as a string.

**Test cases (input -> expected output patterns):**

1. **Discriminated unions from displayOptions (TYGEN-02):**
   Input: Slack schema with resource=message,operation=post properties that have displayOptions.show
   Expected: Separate interfaces `SlackMessagePost` and `SlackChannelCreate` with resource/operation as literal type discriminants. Properties only appear in the interface where their displayOptions.show conditions match.

2. **String literal unions from options (TYGEN-03):**
   Input: Property with type='options' and options=[{value:'text'},{value:'block'}]
   Expected: TypeScript type `'text' | 'block'` (not `string`)

3. **ResourceLocator support (TYGEN-04):**
   Input: Property with type='resourceLocator'
   Expected: Type accepts `ResourceLocator | string` where ResourceLocator is `{ mode: 'list'|'id'|'name'|'url', value: string }`

4. **Collection typing (TYGEN-05):**
   Input: Property with type='collection' containing sub-properties
   Expected: Typed object with optional fields matching sub-property names and types

5. **FixedCollection typing (TYGEN-05):**
   Input: Property with type='fixedCollection' containing named groups with values
   Expected: Typed object with group names as keys, each containing typed fields

6. **Full node generation (TYGEN-01):**
   Input: Complete Slack schema
   Expected: Union type `SlackNode = SlackMessagePost | SlackMessagePostReply | SlackChannelCreate | ...` with Expression<T> wrapper type for expression-capable fields
  </behavior>
  <implementation>
**Algorithm overview:**

1. `analyzeDisplayOptions(properties: N8nProperty[])` in conditional.ts:
   - Find "resource" and "operation" properties (the discriminant fields)
   - For each resource value, find all operations (via displayOptions.show)
   - For each resource+operation combo, collect all properties whose displayOptions.show matches
   - Handle nested displayOptions (e.g., messageType within message.post)
   - Return a tree: `Map<string, Map<string, N8nProperty[]>>` (resource -> operation -> properties)

2. `buildDiscriminatedUnions(nodeName: string, tree, allProperties)` in conditional.ts:
   - For each resource+operation combo, generate an interface with:
     - resource: literal type (e.g., `'message'`)
     - operation: literal type (e.g., `'post'`)
     - All properties whose displayOptions.show matches this combo
   - Properties with further displayOptions branching (e.g., messageType) create sub-unions
   - Return TypeScript source string

3. `generateNodeType(schema: N8nNodeType)` in generator.ts:
   - Analyze displayOptions structure
   - If has resource/operation pattern: use discriminated unions
   - If no resource/operation (simple node like Set): generate single interface
   - Map property types: string->string, number->number, boolean->boolean, options->literal union, resourceLocator->ResourceLocator|string, collection->typed object, fixedCollection->typed object
   - Wrap expression-capable fields with `T | Expression<T>` (skip noDataExpression fields)
   - Mark required fields (required: true) as non-optional, others as optional

4. `generateNodeTypes(schemas: N8nNodeType[])` in generator.ts:
   - Generate shared types (Expression<T>, ResourceLocator)
   - Generate each node type
   - Combine into single output string

5. `cli/generate.ts`:
   - Read all cached schemas
   - Call generateNodeTypes
   - Write to generated/nodes.ts
   - Format with basic indentation

**Expression type:**
```typescript
type Expression<T> = { __expression: string } & { __type?: T };
// Allows: text: 'hello' or text: expr('={{$json.name}}')
```

**ResourceLocator type:**
```typescript
interface ResourceLocator {
  __rl: true;
  mode: 'list' | 'id' | 'name' | 'url';
  value: string;
  cachedResultName?: string;
  cachedResultUrl?: string;
}
```
  </implementation>
</feature>

<verification>
1. `npx vitest run` — all generator tests pass
2. `npx tsx cli/generate.ts` — generates `generated/nodes.ts` from cached schemas
3. `npx tsc --noEmit` — generated types compile without errors
4. Generated Slack types have separate interfaces per resource+operation combo
5. Generated types include string literal unions for options fields
6. ResourceLocator fields accept both object and string forms
</verification>

<success_criteria>
- All TDD tests pass (RED -> GREEN -> REFACTOR complete)
- displayOptions.show conditionals produce correct discriminated unions
- options fields are string literal unions
- ResourceLocator supports mode/value and string shorthand
- Collection/FixedCollection generate typed nested objects
- `npm run generate` produces compilable TypeScript from cached schemas
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
