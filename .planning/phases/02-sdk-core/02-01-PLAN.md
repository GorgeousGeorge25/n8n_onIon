---
phase: 02-sdk-core
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/expressions/reference.ts
  - src/expressions/template.ts
  - src/expressions/tests/expressions.test.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Node output reference produces correct $node['Name'].json.field syntax"
    - "Nested property access chains compile to dot-notation paths"
    - "Template literals with embedded references compile to n8n expression concatenation"
    - "Plain string template literals (no references) return plain strings"
  artifacts:
    - path: "src/expressions/reference.ts"
      provides: "Node output reference builder with Proxy-based property chaining"
      exports: ["ref"]
    - path: "src/expressions/template.ts"
      provides: "Tagged template literal that compiles to n8n expression strings"
      exports: ["expr"]
    - path: "src/expressions/tests/expressions.test.ts"
      provides: "TDD test suite for expression system"
      min_lines: 80
  key_links:
    - from: "src/expressions/reference.ts"
      to: "generated/nodes.ts Expression<T>"
      via: "Returns Expression<T> compatible values"
      pattern: "__expression"
    - from: "src/expressions/template.ts"
      to: "src/expressions/reference.ts"
      via: "Accepts ref() output in template interpolation"
      pattern: "ref.*template"
---

<objective>
Build the expression system that compiles TypeScript references into n8n expression syntax.

Purpose: Node output references (`$node['Name'].json.field`) and template literals are the #1 source of runtime errors in hand-crafted n8n JSON. This plan creates type-safe helpers that produce correct expression strings, eliminating syntax errors. These expression helpers will be consumed by the workflow builder (Plan 02-02) when setting node parameters.

Output: Two exported functions (`ref` and `expr`) that produce n8n-compatible expression strings, with comprehensive TDD test coverage.
</objective>

<execution_context>
@/Users/jurissleiners/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jurissleiners/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 type definitions (Expression<T> type already defined)
@generated/nodes.ts (first 30 lines - Expression and ResourceLocator types)
@src/schema/types.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for expression system</name>
  <files>src/expressions/tests/expressions.test.ts</files>
  <action>
Create test file with test cases covering EXPR-01 and EXPR-02:

**EXPR-01: Node output references**
```typescript
import { ref } from '../../expressions/reference.js';

// Basic reference
expect(ref('Webhook').out.body.name.toString()).toBe("={{ $node['Webhook'].json.body.name }}");

// Nested access
expect(ref('HTTP Request').out.data.items[0].id.toString()).toBe("={{ $node['HTTP Request'].json.data.items[0].id }}");

// Reference produces Expression-compatible object
const r = ref('Webhook').out.body.email;
expect(r.__expression).toBe("$node['Webhook'].json.body.email");

// .out starts the json path (maps to .json in n8n expressions)
expect(ref('Set').out.name.toString()).toBe("={{ $node['Set'].json.name }}");
```

**EXPR-02: Template literals**
```typescript
import { expr } from '../../expressions/template.js';

// Template with references
const webhook = ref('Webhook');
const result = expr`Hello ${webhook.out.body.name}, your email is ${webhook.out.body.email}`;
expect(result).toBe("={{ 'Hello ' + $node['Webhook'].json.body.name + ', your email is ' + $node['Webhook'].json.body.email }}");

// Plain string (no references) returns plain string
expect(expr`Hello World`).toBe("Hello World");

// Template with single reference
expect(expr`${webhook.out.body.name}`).toBe("={{ $node['Webhook'].json.body.name }}");

// Mixed literal and reference
expect(expr`Name: ${webhook.out.body.name}`).toBe("={{ 'Name: ' + $node['Webhook'].json.body.name }}");
```

Run `npx vitest run src/expressions` -- tests must FAIL (modules don't exist yet).
  </action>
  <verify>npx vitest run src/expressions 2>&1 | grep -E "FAIL|Cannot find module" (tests fail because implementation doesn't exist)</verify>
  <done>Test file exists with 8+ test cases covering ref(), expr(), nested access, template interpolation. All tests fail.</done>
</task>

<task type="auto">
  <name>Task 2: Implement expression system to pass tests</name>
  <files>src/expressions/reference.ts, src/expressions/template.ts, src/index.ts</files>
  <action>
**src/expressions/reference.ts:**

Create `ref(nodeName: string)` that returns a Proxy-based object for building n8n expression paths:

```typescript
export function ref(nodeName: string) {
  // Returns object with .out property that starts JSON path building
  // .out maps to .json in n8n expressions
  // Each property access appends to the path
  // .toString() wraps in ={{ ... }}
  // .__expression returns raw expression string (Expression<T> compatible)
}
```

Implementation approach:
- Use JavaScript Proxy to intercept property access
- Track path segments: `ref('Webhook').out.body.name` -> segments: ['body', 'name']
- `.out` is the entry point that starts path tracking (maps to `json` in n8n)
- `toString()` returns `={{ $node['Webhook'].json.body.name }}`
- `__expression` property returns `$node['Webhook'].json.body.name` (without ={{ }})
- Support bracket notation for array indices: `.items[0]` (if accessed via proxy)
- The proxy should handle `Symbol.toPrimitive` for template literal interpolation

**src/expressions/template.ts:**

Create `expr` tagged template literal function:

```typescript
export function expr(strings: TemplateStringsArray, ...values: any[]): string {
  // If no interpolated values, return plain string
  // If has values, build n8n concatenation expression:
  // ={{ 'literal part' + $node['X'].json.field + 'literal part' }}
  // Skip empty string parts
  // Each value should have __expression property (from ref())
}
```

Implementation:
- Check if any values exist; if not, return `strings[0]`
- Build expression parts array: string literals become `'literal'`, refs become their `__expression`
- Join with ` + `
- Wrap in `={{ ... }}`
- Handle edge case: single reference without surrounding text

**src/index.ts:** Add exports for `ref` and `expr`.

Run `npx vitest run src/expressions` -- all tests must PASS.
Run `npx tsc --noEmit` -- zero TypeScript errors.
  </action>
  <verify>npx vitest run src/expressions && npx tsc --noEmit</verify>
  <done>All expression tests pass. ref() produces correct $node expression syntax. expr() template literals compile to n8n concatenation. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/expressions` - All tests pass
2. `npx tsc --noEmit` - Zero TypeScript errors
3. `ref('Webhook').out.body.name.toString()` contains `$node['Webhook'].json.body.name`
4. `expr` tagged template produces `={{ ... }}` wrapped expressions
5. Expression objects have `__expression` property compatible with `Expression<T>` type
</verification>

<success_criteria>
- EXPR-01: ref('NodeName').out.field compiles to $node['NodeName'].json.field syntax
- EXPR-02: expr`text ${ref}` compiles to ={{ 'text ' + expression }} syntax
- All tests pass, TypeScript compiles, exports available from src/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/02-sdk-core/02-01-SUMMARY.md`
</output>
