---
phase: 02-sdk-core
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/builder/workflow.ts
  - src/builder/types.ts
  - src/builder/tests/workflow.test.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "workflow('name') creates a workflow context with the given name"
    - "wf.trigger() adds a trigger node and returns a reference for connections"
    - "wf.node() adds an action node and returns a reference for connections"
    - "wf.connect() links two nodes by their returned references"
    - "Connecting to a non-existent node throws a clear error"
    - "Duplicate node names throw a clear error"
  artifacts:
    - path: "src/builder/workflow.ts"
      provides: "Workflow builder with trigger(), node(), connect() methods"
      exports: ["workflow"]
    - path: "src/builder/types.ts"
      provides: "TypeScript types for workflow builder internals"
      exports: ["WorkflowBuilder", "NodeRef", "WorkflowNode"]
    - path: "src/builder/tests/workflow.test.ts"
      provides: "TDD test suite for workflow builder"
      min_lines: 100
  key_links:
    - from: "src/builder/workflow.ts"
      to: "generated/nodes.ts"
      via: "Accepts generated node type parameters"
      pattern: "parameters"
    - from: "src/builder/workflow.ts connect()"
      to: "src/builder/workflow.ts trigger()/node()"
      via: "connect() validates node references returned by trigger()/node()"
      pattern: "NodeRef"
---

<objective>
Build the workflow builder API that creates typed workflow structures from fluent method calls.

Purpose: The builder is the primary developer interface -- `workflow('My Flow')` creates a context, `wf.trigger()` and `wf.node()` add nodes with typed parameters, and `wf.connect()` links them. This plan creates the internal data model and builder methods. The actual JSON compilation happens in Phase 3; this plan builds the in-memory workflow representation.

Output: Exported `workflow()` factory function with `trigger()`, `node()`, `connect()` methods, plus comprehensive TDD test coverage.
</objective>

<execution_context>
@/Users/jurissleiners/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jurissleiners/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Generated types showing node type structure
@generated/nodes.ts (first 30 lines - Expression and ResourceLocator types)
@src/schema/types.ts
@src/codegen/generator.ts (extractNodeName function for reference)
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for workflow builder</name>
  <files>src/builder/tests/workflow.test.ts</files>
  <action>
Create test file with test cases covering BUILD-01 through BUILD-04:

**BUILD-01: workflow() factory**
```typescript
import { workflow } from '../../builder/workflow.js';

it('creates workflow with given name', () => {
  const wf = workflow('My Workflow');
  expect(wf.name).toBe('My Workflow');
});

it('starts with empty nodes and connections', () => {
  const wf = workflow('Test');
  expect(wf.getNodes()).toEqual([]);
  expect(wf.getConnections()).toEqual([]);
});
```

**BUILD-02: wf.trigger()**
```typescript
it('adds a trigger node', () => {
  const wf = workflow('Test');
  const webhook = wf.trigger('Webhook', 'n8n-nodes-base.webhook', {
    httpMethod: 'POST',
    path: 'my-hook'
  });

  expect(wf.getNodes()).toHaveLength(1);
  expect(wf.getNodes()[0].name).toBe('Webhook');
  expect(wf.getNodes()[0].type).toBe('n8n-nodes-base.webhook');
  expect(wf.getNodes()[0].parameters.httpMethod).toBe('POST');
});

it('returns a node reference for connections', () => {
  const wf = workflow('Test');
  const webhook = wf.trigger('Webhook', 'n8n-nodes-base.webhook', {});
  expect(webhook.name).toBe('Webhook');
});
```

**BUILD-03: wf.node()**
```typescript
it('adds an action node', () => {
  const wf = workflow('Test');
  const slack = wf.node('Send Slack', 'n8n-nodes-base.slack', {
    resource: 'message',
    operation: 'post',
    text: 'Hello'
  });

  expect(wf.getNodes()).toHaveLength(1);
  expect(wf.getNodes()[0].name).toBe('Send Slack');
  expect(wf.getNodes()[0].type).toBe('n8n-nodes-base.slack');
  expect(wf.getNodes()[0].parameters.resource).toBe('message');
});

it('rejects duplicate node names', () => {
  const wf = workflow('Test');
  wf.node('Slack', 'n8n-nodes-base.slack', {});
  expect(() => wf.node('Slack', 'n8n-nodes-base.slack', {})).toThrow('duplicate');
});
```

**BUILD-04: wf.connect()**
```typescript
it('connects two nodes', () => {
  const wf = workflow('Test');
  const webhook = wf.trigger('Webhook', 'n8n-nodes-base.webhook', {});
  const slack = wf.node('Slack', 'n8n-nodes-base.slack', {});

  wf.connect(webhook, slack);

  const connections = wf.getConnections();
  expect(connections).toHaveLength(1);
  expect(connections[0].from).toBe('Webhook');
  expect(connections[0].to).toBe('Slack');
});

it('supports chaining multiple connections', () => {
  const wf = workflow('Test');
  const webhook = wf.trigger('Webhook', 'n8n-nodes-base.webhook', {});
  const set = wf.node('Set Data', 'n8n-nodes-base.set', {});
  const slack = wf.node('Slack', 'n8n-nodes-base.slack', {});

  wf.connect(webhook, set);
  wf.connect(set, slack);

  expect(wf.getConnections()).toHaveLength(2);
});

it('supports output index for branching nodes (IF)', () => {
  const wf = workflow('Test');
  const ifNode = wf.node('Check', 'n8n-nodes-base.if', {});
  const trueNode = wf.node('True Path', 'n8n-nodes-base.set', {});
  const falseNode = wf.node('False Path', 'n8n-nodes-base.set', {});

  wf.connect(ifNode, trueNode, 0); // true output
  wf.connect(ifNode, falseNode, 1); // false output

  const conns = wf.getConnections();
  expect(conns[0].outputIndex).toBe(0);
  expect(conns[1].outputIndex).toBe(1);
});
```

Run `npx vitest run src/builder` -- tests must FAIL.
  </action>
  <verify>npx vitest run src/builder 2>&1 | grep -E "FAIL|Cannot find module" (tests fail because implementation doesn't exist)</verify>
  <done>Test file exists with 8+ test cases covering workflow(), trigger(), node(), connect(). All tests fail.</done>
</task>

<task type="auto">
  <name>Task 2: Implement workflow builder to pass tests</name>
  <files>src/builder/workflow.ts, src/builder/types.ts, src/index.ts</files>
  <action>
**src/builder/types.ts:**

Define internal types for the workflow builder:

```typescript
export interface NodeRef {
  name: string;         // Node name (unique within workflow)
}

export interface WorkflowNode {
  name: string;                    // Display name / identifier
  type: string;                    // n8n node type (e.g., 'n8n-nodes-base.slack')
  parameters: Record<string, unknown>;  // Node configuration
}

export interface WorkflowConnection {
  from: string;         // Source node name
  to: string;           // Target node name
  outputIndex: number;  // Output index (0 for main, 1+ for branches like IF false)
}

export interface WorkflowBuilder {
  name: string;
  trigger(name: string, type: string, parameters: Record<string, unknown>): NodeRef;
  node(name: string, type: string, parameters: Record<string, unknown>): NodeRef;
  connect(from: NodeRef, to: NodeRef, outputIndex?: number): void;
  getNodes(): WorkflowNode[];
  getConnections(): WorkflowConnection[];
}
```

**src/builder/workflow.ts:**

Implement the `workflow()` factory function:

```typescript
export function workflow(name: string): WorkflowBuilder {
  const nodes: WorkflowNode[] = [];
  const connections: WorkflowConnection[] = [];
  const nodeNames = new Set<string>();

  function addNode(name, type, parameters): NodeRef {
    if (nodeNames.has(name)) throw new Error(`Node name "${name}" is duplicate...`);
    nodeNames.add(name);
    nodes.push({ name, type, parameters });
    return { name };
  }

  return {
    name,
    trigger(name, type, params) { return addNode(name, type, params); },
    node(name, type, params) { return addNode(name, type, params); },
    connect(from, to, outputIndex = 0) {
      // Validate both nodes exist
      if (!nodeNames.has(from.name)) throw new Error(`Unknown node: "${from.name}"`);
      if (!nodeNames.has(to.name)) throw new Error(`Unknown node: "${to.name}"`);
      connections.push({ from: from.name, to: to.name, outputIndex });
    },
    getNodes() { return [...nodes]; },
    getConnections() { return [...connections]; }
  };
}
```

Key design decisions:
- `trigger()` and `node()` have identical implementation for now (Phase 3 compiler will differentiate)
- Parameters are `Record<string, unknown>` at runtime; TypeScript generics in Phase 3 will add compile-time checking using generated types
- `connect()` validates node existence at call time (not deferred)
- `outputIndex` defaults to 0 (main output), use 1 for IF false branch
- `getNodes()` and `getConnections()` return copies to prevent mutation

**src/index.ts:** Add exports for `workflow` and builder types.

Run `npx vitest run src/builder` -- all tests must PASS.
Run `npx tsc --noEmit` -- zero TypeScript errors.
  </action>
  <verify>npx vitest run src/builder && npx tsc --noEmit</verify>
  <done>All builder tests pass. workflow() creates context, trigger()/node() add nodes with params, connect() links them with validation. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/builder` - All tests pass
2. `npx tsc --noEmit` - Zero TypeScript errors
3. `workflow('name')` returns builder with name property
4. `wf.trigger()` and `wf.node()` add nodes to internal list
5. `wf.connect()` creates connections and validates node references
6. Duplicate names throw errors
7. Output index support for branching nodes (IF true/false)
</verification>

<success_criteria>
- BUILD-01: workflow('name') creates workflow context
- BUILD-02: wf.trigger() adds trigger node with typed parameters
- BUILD-03: wf.node() adds action node with typed parameters
- BUILD-04: wf.connect() links nodes with validated references and output index support
- All tests pass, TypeScript compiles, exports available from src/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/02-sdk-core/02-02-SUMMARY.md`
</output>
