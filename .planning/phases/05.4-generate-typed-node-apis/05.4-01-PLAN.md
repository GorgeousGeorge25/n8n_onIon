---
phase: 05.4-generate-typed-node-apis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/codegen/factory-generator.ts
  - cli/generate.ts
  - generated/node-catalog.json
autonomous: true

must_haves:
  truths:
    - "A factory generator reads all 797 schemas and produces per-category factory modules and a discovery catalog"
    - "The discovery catalog lists every node with name, type string, category, resources/operations, credentials, and required params"
    - "The catalog is compact enough for Claude to read in one shot (<200KB)"
  artifacts:
    - path: "src/codegen/factory-generator.ts"
      provides: "Schema-to-factory code generation engine"
      exports: ["generateFactoryModules", "generateNodeCatalog"]
    - path: "generated/node-catalog.json"
      provides: "Compact discovery catalog for all 797 nodes"
  key_links:
    - from: "src/codegen/factory-generator.ts"
      to: "src/schema/cache.ts"
      via: "readAllSchemas()"
      pattern: "readAllSchemas"
    - from: "cli/generate.ts"
      to: "src/codegen/factory-generator.ts"
      via: "import generateNodeCatalog, generateFactoryModules"
      pattern: "generateFactoryModules|generateNodeCatalog"
---

<objective>
Build the factory code generator and node discovery catalog.

Purpose: This is the foundation for Phase 5.4 — the generator reads all 797 cached schemas and produces: (1) per-category TypeScript factory module source code as strings, and (2) a compact JSON catalog for Claude to discover nodes without reading massive generated files.

Output:
- `src/codegen/factory-generator.ts` — generator engine with `generateFactoryModules()` and `generateNodeCatalog()`
- `generated/node-catalog.json` — compact catalog of all 797 nodes
- Updated `cli/generate.ts` — now also generates catalog and factory modules
</objective>

<execution_context>
@/Users/jurissleiners/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jurissleiners/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/codegen/typed-api.ts
@src/codegen/generator.ts
@src/codegen/conditional.ts
@src/schema/cache.ts
@src/schema/types.ts
@src/builder/types.ts
@cli/generate.ts
@generated/nodes.ts (first 80 lines for structure reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create factory generator engine</name>
  <files>src/codegen/factory-generator.ts</files>
  <action>
Create `src/codegen/factory-generator.ts` that exports two functions:

**`generateNodeCatalog(schemas: N8nNodeType[]): NodeCatalog`**

Produces a compact JSON catalog. Each entry has:
- `name`: display name (e.g., "Slack")
- `type`: n8n type string (e.g., "n8n-nodes-base.slack")
- `group`: group array (e.g., ["output"])
- `credentials`: credential type names (e.g., ["slackApi", "slackOAuth2Api"])
- `operations`: for resource/operation nodes, a map of `{ [resource]: string[] }` (e.g., `{ message: ["post", "update", "delete"], channel: ["create", "archive"] }`)
- `simple`: boolean — true if no resource/operation pattern

The catalog type:
```typescript
export interface CatalogEntry {
  name: string;
  type: string;
  group: string[];
  credentials: string[];
  operations: Record<string, string[]> | null;  // null for simple nodes
  simple: boolean;
}
export interface NodeCatalog {
  generated: string;  // ISO timestamp
  count: number;
  nodes: CatalogEntry[];
}
```

**`generateFactoryModules(schemas: N8nNodeType[]): Map<string, string>`**

Returns a Map of `filename -> TypeScript source code` for per-category factory modules. The splitting strategy:

1. **Group nodes by package prefix**: `n8n-nodes-base` nodes go into category-based files; `@n8n/n8n-nodes-langchain` nodes go into `langchain.ts`.

2. **For n8n-nodes-base nodes**, group by the node's `group[]` array value:
   - `trigger` group -> `generated/factories/triggers.ts`
   - `transform` group -> `generated/factories/transform.ts`
   - `input` group -> `generated/factories/input.ts`
   - `output` group -> `generated/factories/output.ts`
   - Other/multiple -> `generated/factories/other.ts`

3. **Each generated factory file** contains:
   - Imports from `../../generated/nodes.js` for the relevant type interfaces
   - A `makeNode` helper (same pattern as existing typed-api.ts)
   - For **simple nodes** (no resource/operation): a flat factory function
     ```typescript
     export function createWebhook(name: string, params: Partial<WebhookNode>): WorkflowNode {
       return { name, type: 'n8n-nodes-base.webhook', parameters: params as Record<string, unknown> };
     }
     ```
   - For **resource/operation nodes**: a nested object factory
     ```typescript
     export const slack = {
       message: {
         post: (name: string, params: Partial<Omit<SlackMessagePost, 'resource' | 'operation'>>): WorkflowNode => ({
           name, type: 'n8n-nodes-base.slack',
           parameters: { ...params as Record<string, unknown>, resource: 'message', operation: 'post' }
         }),
         // ... other operations
       },
       // ... other resources
     };
     ```

4. **Each file must stay under 500 lines.** If a category file would exceed 500 lines, split further alphabetically (e.g., `output-a-m.ts`, `output-n-z.ts`). Use a simple heuristic: ~5 lines per simple factory, ~7 lines per resource/operation factory. Estimate before generating and split proactively.

5. **An index file** `generated/factories/index.ts` re-exports everything and provides the `createTypedNodes()` function that assembles all factories into the nested `TypedNodes` structure.

Key implementation details:
- Use `extractNodeName()` logic from `generator.ts` to derive clean names (reuse or import)
- Use `analyzeDisplayOptions()` from `conditional.ts` to detect resource/operation patterns
- The generator returns source code as strings — it does NOT write files (that's the CLI's job)
- Import type references point to `../../generated/nodes.js` (relative from generated/factories/)
- The WorkflowNode import comes from `../../src/builder/types.js`

Export the `extractNodeName` function from generator.ts (currently private) so factory-generator can reuse it.
  </action>
  <verify>
  `npx tsc --noEmit src/codegen/factory-generator.ts` compiles without errors.
  Manually test: import and call `generateNodeCatalog` with a few test schemas to verify output shape.
  </verify>
  <done>
  `generateNodeCatalog()` produces a valid catalog with all 797 entries.
  `generateFactoryModules()` produces a Map of filename->source-code strings.
  No generated factory file exceeds 500 lines.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CLI to generate catalog and factories</name>
  <files>cli/generate.ts, generated/node-catalog.json</files>
  <action>
Update `cli/generate.ts` to also call the new generator functions after existing type generation:

1. After writing `generated/nodes.ts` (existing behavior), also:
   - Call `generateNodeCatalog(schemas)` and write to `generated/node-catalog.json`
   - Call `generateFactoryModules(schemas)` and write each entry to `generated/factories/{filename}`
   - Create `generated/factories/` directory if it doesn't exist

2. Add a `--catalog-only` flag that skips type generation and only regenerates the catalog (fast path for iteration).

3. Run the updated CLI: `npx tsx cli/generate.ts` to actually produce all generated files.

4. Verify:
   - `generated/node-catalog.json` exists and has 797 entries
   - `generated/factories/` contains per-category .ts files
   - No single factory file exceeds 500 lines (use `wc -l` to check)
  </action>
  <verify>
  `npx tsx cli/generate.ts` completes successfully.
  `cat generated/node-catalog.json | python3 -c "import json,sys; d=json.load(sys.stdin); print(d['count'])"` prints 797.
  `wc -l generated/factories/*.ts` — no file exceeds 500 lines.
  `du -sh generated/node-catalog.json` — under 200KB.
  </verify>
  <done>
  CLI generates catalog and factory modules alongside existing type definitions.
  All 797 nodes present in catalog.
  Factory files split per-category, each under 500 lines.
  Catalog under 200KB.
  </done>
</task>

</tasks>

<verification>
- `npx tsx cli/generate.ts` runs without errors
- `generated/node-catalog.json` has 797 entries
- `generated/factories/` contains multiple .ts files, none over 500 lines
- `npx tsc --noEmit` passes for the generator source
</verification>

<success_criteria>
- Factory generator reads all 797 schemas and produces per-category factory modules
- Node catalog JSON is compact (<200KB) and lists all nodes with type, group, credentials, and operations
- No generated file exceeds 500 lines
- CLI generates everything in one `npm run generate` command
</success_criteria>

<output>
After completion, create `.planning/phases/05.4-generate-typed-node-apis/05.4-01-SUMMARY.md`
</output>
